[["Map",1,2,9,10,65,236,19,244],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.3.0","content-config-digest","1d761b479101406a","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://veloi.me\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"prefetch\":true,\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"shiki\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"vesper\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","snippets",["Map",11,12,35,36,54,55,80,81,104,105,135,136,160,161,184,185,208,209],"dimensions",{"id":11,"data":13,"body":20,"filePath":21,"digest":22,"rendered":23,"legacyId":34},{"title":14,"description":15,"pubDate":16,"implementation":17},"Dimensions","Helpers to infer height and width of any dimensions",["Date","2025-02-22T00:00:00.000Z"],{"id":18,"collection":19},"dimensions.ts","snippetImplementations","## Context\n\nAllows any variant of dimensions to be accepted in your application code.\nThis is mainly used as a shared dependency of other snippets interacting with dimensions.","src/content/snippets/dimensions.md","a0b6c199972bf100",{"html":24,"metadata":25},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>Allows any variant of dimensions to be accepted in your application code.\nThis is mainly used as a shared dependency of other snippets interacting with dimensions.\u003C/p>",{"headings":26,"imagePaths":31,"frontmatter":32},[27],{"depth":28,"slug":29,"text":30},2,"context","Context",[],{"title":14,"description":15,"pubDate":33,"implementation":18},"Feb 22 2025","dimensions.md","state-serialization",{"id":35,"data":37,"body":43,"filePath":44,"digest":45,"rendered":46,"legacyId":53},{"title":38,"description":39,"pubDate":40,"implementation":41},"State Serialization","De/serialize your state I/O of safe JSON",["Date","2025-02-22T00:00:00.000Z"],{"id":42,"collection":19},"state-serialization.ts","## Context\n\nAllows for safe serialization of any kind of state within your application for storing.\nIt comes with basic `include` and `exclude` options to omit keys you don't want to serialize.","src/content/snippets/state-serialization.md","f00efe183d39128e",{"html":47,"metadata":48},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>Allows for safe serialization of any kind of state within your application for storing.\nIt comes with basic \u003Ccode>include\u003C/code> and \u003Ccode>exclude\u003C/code> options to omit keys you don’t want to serialize.\u003C/p>",{"headings":49,"imagePaths":51,"frontmatter":52},[50],{"depth":28,"slug":29,"text":30},[],{"title":38,"description":39,"pubDate":33,"implementation":42},"state-serialization.md","react/scroll-threshold",{"id":54,"data":56,"body":68,"filePath":69,"digest":70,"rendered":71,"legacyId":79},{"title":57,"description":58,"usage":59,"pubDate":61,"tags":62,"collection":64,"implementation":66},"React Scroll Threshold","Performantly check the scroll position of an element",{"id":60,"collection":19},"use-scroll-threshold.example.tsx",["Date","2025-02-22T00:00:00.000Z"],[63],"react",{"id":63,"collection":65},"snippetCollections",{"id":67,"collection":19},"use-scroll-threshold.ts","## Context\n\nBasic hook to check if scroll position of the specified element ref has exceeded a threshold. If an elements is not specified, `window.scrollY` is used. The threshold is _not_ inclusive.\n\nThis hook will default to `false` when used in a server-side rendering environment and only update when hooks run on the client.\n\nThe advantage to this hook is it that does not cause unnecessary re-renders when scrolling; it does the scroll comparison outside of React.","src/content/snippets/react/scroll-threshold.md","a19d9a8b9c22ecd6",{"html":72,"metadata":73},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>Basic hook to check if scroll position of the specified element ref has exceeded a threshold. If an elements is not specified, \u003Ccode>window.scrollY\u003C/code> is used. The threshold is \u003Cem>not\u003C/em> inclusive.\u003C/p>\n\u003Cp>This hook will default to \u003Ccode>false\u003C/code> when used in a server-side rendering environment and only update when hooks run on the client.\u003C/p>\n\u003Cp>The advantage to this hook is it that does not cause unnecessary re-renders when scrolling; it does the scroll comparison outside of React.\u003C/p>",{"headings":74,"imagePaths":76,"frontmatter":77},[75],{"depth":28,"slug":29,"text":30},[],{"title":57,"description":58,"pubDate":33,"tags":78,"collection":63,"implementation":67,"usage":60},[63],"react/scroll-threshold.md","react/detect-sticky",{"id":80,"data":82,"body":92,"filePath":93,"digest":94,"rendered":95,"legacyId":103},{"title":83,"description":84,"usage":85,"pubDate":87,"tags":88,"collection":89,"implementation":90},"React Detect Sticky","Watch for sticky elements being hoisted",{"id":86,"collection":19},"use-detect-sticky.example.tsx",["Date","2025-02-22T00:00:00.000Z"],[63],{"id":63,"collection":65},{"id":91,"collection":19},"use-detect-sticky.ts","## Context\n\nA basic hook to watch for when sticky elements are hoisted to their set position. This is useful for conditionally showing \"Scroll to top\" buttons.\n\nThe caveat is the sticky element must have a `-1px` offset.","src/content/snippets/react/detect-sticky.md","5643148ac50f76ac",{"html":96,"metadata":97},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>A basic hook to watch for when sticky elements are hoisted to their set position. This is useful for conditionally showing “Scroll to top” buttons.\u003C/p>\n\u003Cp>The caveat is the sticky element must have a \u003Ccode>-1px\u003C/code> offset.\u003C/p>",{"headings":98,"imagePaths":100,"frontmatter":101},[99],{"depth":28,"slug":29,"text":30},[],{"title":83,"description":84,"pubDate":33,"tags":102,"collection":63,"implementation":91,"usage":86},[63],"react/detect-sticky.md","react/tracked-values",{"id":104,"data":106,"body":68,"filePath":122,"digest":123,"rendered":124,"legacyId":134},{"title":107,"description":108,"usage":109,"pubDate":114,"tags":115,"collection":116,"implementation":117},"Tracked Values","Persist prior state by conditions",[110,112],{"id":111,"collection":19},"use-track-value.example.tsx",{"id":113,"collection":19},"use-throwing-transform-track-value.example.tsx",["Date","2025-07-27T23:00:00.000Z"],[63],{"id":63,"collection":65},[118,120],{"id":119,"collection":19},"use-track-value.ts",{"id":121,"collection":19},"use-throwing-transform-track-value.ts","src/content/snippets/react/tracked-values.md","70faa7d65831505e",{"html":72,"metadata":125},{"headings":126,"imagePaths":128,"frontmatter":129},[127],{"depth":28,"slug":29,"text":30},[],{"title":107,"description":108,"pubDate":130,"tags":131,"collection":63,"implementation":132,"usage":133},"Jul 28 2025",[63],[119,121],[111,113],"react/tracked-values.md","zustand/draft-store",{"id":135,"data":137,"body":148,"filePath":149,"digest":150,"rendered":151,"legacyId":159},{"title":138,"description":139,"usage":140,"pubDate":142,"tags":143,"collection":145,"implementation":146},"Zustand Draft Store","Update your store in batch through a clone",{"id":141,"collection":19},"draft-store.example.tsx",["Date","2025-02-22T00:00:00.000Z"],[144],"zustand",{"id":144,"collection":65},{"id":147,"collection":19},"draft-store.tsx","## Context\n\nThis allows for a store to be updated in batch by modifying state in a cloned store and pushing to the original store when ready.\n\nThis is particularly useful in user interfaces when you don't want updates to a store in a UI to proprogate before the user has finished.\n\n- `createDraftStore` will immediately wrap and create a copy of the store with the additional methods.\n- `createDraftStoreContext` will call `createDraftStore` within a React provider.\n\nIf the original store is modifed when a draft store instance is living, the draft store will _not_ be updated.\n\nOn `push()`, the **entire** store will be updated, including state that has _not_ been modified.","src/content/snippets/zustand/draft-store.md","93003af67bb38cd3",{"html":152,"metadata":153},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>This allows for a store to be updated in batch by modifying state in a cloned store and pushing to the original store when ready.\u003C/p>\n\u003Cp>This is particularly useful in user interfaces when you don’t want updates to a store in a UI to proprogate before the user has finished.\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ccode>createDraftStore\u003C/code> will immediately wrap and create a copy of the store with the additional methods.\u003C/li>\n\u003Cli>\u003Ccode>createDraftStoreContext\u003C/code> will call \u003Ccode>createDraftStore\u003C/code> within a React provider.\u003C/li>\n\u003C/ul>\n\u003Cp>If the original store is modifed when a draft store instance is living, the draft store will \u003Cem>not\u003C/em> be updated.\u003C/p>\n\u003Cp>On \u003Ccode>push()\u003C/code>, the \u003Cstrong>entire\u003C/strong> store will be updated, including state that has \u003Cem>not\u003C/em> been modified.\u003C/p>",{"headings":154,"imagePaths":156,"frontmatter":157},[155],{"depth":28,"slug":29,"text":30},[],{"title":138,"description":139,"pubDate":33,"tags":158,"collection":144,"implementation":147,"usage":141},[144],"zustand/draft-store.md","zustand/provider",{"id":160,"data":162,"body":172,"filePath":173,"digest":174,"rendered":175,"legacyId":183},{"title":163,"description":164,"usage":165,"pubDate":167,"tags":168,"collection":169,"implementation":170},"Zustand Store Provider","Wrapper to scope your stores via a React context",{"id":166,"collection":19},"provider.example.tsx",["Date","2025-02-22T00:00:00.000Z"],[144],{"id":144,"collection":65},{"id":171,"collection":19},"provider.tsx","## Context\n\nThis allows for your stores to be scoped via a React context. It exports a function to wrap your store with any arguments being forwarded through props.\n\nThe default behaviour of the exported `use` hook will throw if no provider is in scope.\n\nIf you need direct access to the `StoreApi`, you can `.useRoot()` on the hook. This is rarely necessary and only needed for using `.getState` and `.setState` on the store.","src/content/snippets/zustand/provider.md","f0fcf55b1a6d429e",{"html":176,"metadata":177},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>This allows for your stores to be scoped via a React context. It exports a function to wrap your store with any arguments being forwarded through props.\u003C/p>\n\u003Cp>The default behaviour of the exported \u003Ccode>use\u003C/code> hook will throw if no provider is in scope.\u003C/p>\n\u003Cp>If you need direct access to the \u003Ccode>StoreApi\u003C/code>, you can \u003Ccode>.useRoot()\u003C/code> on the hook. This is rarely necessary and only needed for using \u003Ccode>.getState\u003C/code> and \u003Ccode>.setState\u003C/code> on the store.\u003C/p>",{"headings":178,"imagePaths":180,"frontmatter":181},[179],{"depth":28,"slug":29,"text":30},[],{"title":163,"description":164,"pubDate":33,"tags":182,"collection":144,"implementation":171,"usage":166},[144],"zustand/provider.md","zustand/super-json",{"id":184,"data":186,"body":196,"filePath":197,"digest":198,"rendered":199,"legacyId":207},{"title":187,"description":188,"usage":189,"pubDate":191,"tags":192,"collection":193,"implementation":194},"Zustand Superjson Storage","Safely store non-primitive types in a store",{"id":190,"collection":19},"superjson.example.ts",["Date","2025-02-22T00:00:00.000Z"],[144],{"id":144,"collection":65},{"id":195,"collection":19},"superjson.ts","## Context\n\nSame API as the built-in `createJSONStorage()` but with `superjson`.\n\nThis means `Date`, `Map`, `Set` and `BigInt` can be safely stored.","src/content/snippets/zustand/super-json.md","9ce521867ff7331d",{"html":200,"metadata":201},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>Same API as the built-in \u003Ccode>createJSONStorage()\u003C/code> but with \u003Ccode>superjson\u003C/code>.\u003C/p>\n\u003Cp>This means \u003Ccode>Date\u003C/code>, \u003Ccode>Map\u003C/code>, \u003Ccode>Set\u003C/code> and \u003Ccode>BigInt\u003C/code> can be safely stored.\u003C/p>",{"headings":202,"imagePaths":204,"frontmatter":205},[203],{"depth":28,"slug":29,"text":30},[],{"title":187,"description":188,"pubDate":33,"tags":206,"collection":144,"implementation":195,"usage":190},[144],"zustand/super-json.md","zustand/url",{"id":208,"data":210,"body":223,"filePath":224,"digest":225,"rendered":226,"legacyId":235},{"title":211,"description":212,"usage":213,"pubDate":215,"tags":216,"collection":217,"dependencies":218,"implementation":221},"Zustand URL Storage","Store your store's state in a search parameter",{"id":214,"collection":19},"url.example.ts",["Date","2025-02-22T00:00:00.000Z"],[144],{"id":144,"collection":65},[219],{"id":220,"collection":19},"../state-serialization.ts",{"id":222,"collection":19},"url.ts","## Context\n\nAllows you to store your state within `window.location.search`. It uses the `state-serialization` snippet, which utilizes `superjson` (_subject to change_) for stringifying and parsing.\nThis means `Date`, `Map`, `Set` and `BigInt` can be safely stored.","src/content/snippets/zustand/url.md","be425410ed4de70e",{"html":227,"metadata":228},"\u003Ch2 id=\"context\">Context\u003C/h2>\n\u003Cp>Allows you to store your state within \u003Ccode>window.location.search\u003C/code>. It uses the \u003Ccode>state-serialization\u003C/code> snippet, which utilizes \u003Ccode>superjson\u003C/code> (\u003Cem>subject to change\u003C/em>) for stringifying and parsing.\nThis means \u003Ccode>Date\u003C/code>, \u003Ccode>Map\u003C/code>, \u003Ccode>Set\u003C/code> and \u003Ccode>BigInt\u003C/code> can be safely stored.\u003C/p>",{"headings":229,"imagePaths":231,"frontmatter":232},[230],{"depth":28,"slug":29,"text":30},[],{"title":211,"description":212,"pubDate":33,"tags":233,"dependencies":234,"implementation":222,"usage":214,"collection":144},[144],[220],"zustand/url.md",["Map",144,237,63,241],{"id":144,"data":238,"filePath":240},{"id":144,"colour":239},"orange","src/content/collections.json",{"id":63,"data":242,"filePath":240},{"id":63,"colour":243},"sky",["Map",18,245,42,248,251,252,255,256,259,260,263,264,267,268,271,272,275,276,279,280,283,284,287,288,291,292,295,296,299,300,303,304,307,308,311,312],{"id":18,"data":246},{"code":247},"export type AnyDimensions =\n  | { width: number; height: number; aspectRatio?: undefined }\n  | { width: number; aspectRatio: number; height?: undefined }\n  | { height: number; aspectRatio: number; width?: undefined };\n\nexport type SizeDimensions = { width: number; height: number };\n\nexport function sizeDimensions(dimensions: AnyDimensions): SizeDimensions {\n  if (dimensions.aspectRatio !== undefined) {\n    if (dimensions.width !== undefined) {\n      return {\n        width: dimensions.width,\n        height: Math.ceil(dimensions.width * dimensions.aspectRatio),\n      };\n    }\n\n    if (dimensions.height !== undefined) {\n      return {\n        height: dimensions.height,\n        width: Math.ceil(dimensions.height * dimensions.aspectRatio),\n      };\n    }\n  }\n\n  return dimensions;\n}\n",{"id":42,"data":249},{"code":250},"import superjson from \"superjson\";\nimport type { z } from \"zod\";\n\nexport type URLSerializeOptions\u003CT> = {\n  baseURL?: string;\n  paramName?: string;\n} & SerializeOptions\u003CT>;\n\nexport type SerializeOptions\u003CT> = {\n  include?: (keyof T)[];\n  exclude?: (keyof T)[];\n};\n\nexport type StateSerializer\u003CState> = {\n  createURL(state: State, options?: URLSerializeOptions\u003CState>): string;\n  createString(state: State, options?: SerializeOptions\u003CState>): string;\n};\n\nexport const createStateSerializer = \u003C\n  TSchema extends z.ZodType,\n  State extends z.infer\u003CTSchema> = z.infer\u003CTSchema>,\n>(\n  schema: TSchema,\n): StateSerializer\u003CState> => {\n  const createString: StateSerializer\u003CState>[\"createString\"] = (\n    state,\n    options,\n  ) => {\n    let filteredState = { ...state };\n\n    if (options?.include?.length) {\n      filteredState = Object.fromEntries(\n        Object.entries(filteredState).filter(([key]) =>\n          options.include?.includes(key as keyof State),\n        ),\n      ) as State;\n    }\n\n    if (options?.exclude?.length) {\n      filteredState = Object.fromEntries(\n        Object.entries(filteredState).filter(\n          ([key]) => !options.exclude?.includes(key as keyof State),\n        ),\n      ) as State;\n    }\n\n    const validated = schema.parse(filteredState);\n    return superjson.stringify(validated);\n  };\n\n  return {\n    createString,\n    createURL: (state, options): string => {\n      const paramName = options?.paramName || \"state\";\n      const url = options?.baseURL || window.location.pathname;\n      const parameters = new URLSearchParams(url);\n      const [pathname] = url.split(\"?\");\n      const serialized = createString(state, options);\n      parameters.append(paramName, serialized);\n      return `${pathname}?${parameters.toString()}`;\n    },\n  };\n};\n\nexport const createStateDeserializer = \u003C\n  TSchema extends z.ZodType,\n  State extends z.infer\u003CTSchema> = TSchema,\n>(\n  schema: TSchema,\n) => ({\n  fromString(\n    stringifiedState: string | null | undefined,\n    defaultValue?: State,\n  ):\n    | { error: Error; success: false; data?: undefined }\n    | { error?: undefined; data: State; success: true } {\n    try {\n      if (stringifiedState === null) {\n        if (defaultValue !== undefined) {\n          return { data: defaultValue, error: undefined, success: true };\n        }\n\n        throw new Error(\"state is null\");\n      }\n      if (stringifiedState === undefined) {\n        if (defaultValue !== undefined) {\n          return { data: defaultValue, error: undefined, success: true };\n        }\n\n        throw new Error(\"state is undefined\");\n      }\n\n      const decoded = decodeURIComponent(stringifiedState);\n      const parsed = superjson.parse(decoded);\n      return schema.safeParse(parsed);\n    } catch (error) {\n      if (!(error instanceof Error)) {\n        return { error: new Error(String(error)), success: false };\n      }\n\n      return { error, success: false };\n    }\n  },\n});\n","react/use-detect-sticky.example.tsx",{"id":251,"data":253},{"code":254},"import { useRef } from \"react\";\nimport useDetectSticky from \"./use-detect-sticky\";\n\nexport default function Component() {\n\tconst element = useRef\u003CHTMLDivElement>(null);\n\tconst hasScrolled = useDetectSticky(element);\n\n\treturn (\n\t\t\u003Cdiv className=\"overflow-y-auto h-[500px]\">\n\t\t\t{/* -top-px is important */}\n\t\t\t\u003Cdiv className=\"sticky -top-px\" ref={element}>\n\t\t\t\t{hasScrolled && \"You've scrolled\"}\n\t\t\t\u003C/div>\n\t\t\u003C/div>\n\t);\n}\n","react/use-detect-sticky.ts",{"id":255,"data":257},{"code":258},"import { useEffect, useState } from \"react\";\n\nexport default function useDetectSticky(\n  ref: React.RefObject\u003CHTMLElement | null>,\n) {\n  const [isSticky, setIsSticky] = useState(false);\n\n  useEffect(() => {\n    if (!ref.current) return;\n\n    const cachedRef = ref.current;\n    const observer = new IntersectionObserver(\n      ([e]) => {\n        if (!e) return;\n        setIsSticky(e.intersectionRatio \u003C 1);\n      },\n      { threshold: 1 },\n    );\n\n    observer.observe(cachedRef);\n\n    return () => observer.unobserve(cachedRef);\n  }, [ref.current]);\n\n  return isSticky;\n}\n","react/use-scroll-threshold.example.tsx",{"id":259,"data":261},{"code":262},"import { useRef } from \"react\";\nimport useScrollThreshold from \"./use-scroll-threshold\";\n\nexport default function Component() {\n\tconst element = useRef\u003CHTMLDivElement>(null);\n\tconst hasScrolled = useScrollThreshold(100, element);\n\n\treturn (\n\t\t\u003Cdiv className=\"overflow-y-auto h-[200px]\" ref={element}>\n\t\t\t\u003Cdiv className=\"h-[500px] grid place-items-center\">\n\t\t\t\t{hasScrolled && \"You've scrolled\"}\n\t\t\t\u003C/div>\n\t\t\u003C/div>\n\t);\n}\n","react/use-scroll-threshold.ts",{"id":263,"data":265},{"code":266},"import { type RefObject, useEffect, useState } from \"react\";\n\nexport default function useScrollThreshold(\n  threshold: number,\n  ref: RefObject\u003CHTMLElement | null> | null,\n) {\n  const [isScrolled, setIsScrolled] = useState(false);\n\n  useEffect(() => {\n    if (ref && !ref.current) return;\n\n    const updatePosition = () => {\n      const scroll = ref ? (ref.current?.scrollTop ?? 0) : window.scrollY;\n      setIsScrolled(scroll > threshold);\n    };\n\n    const element: GlobalEventHandlers = ref?.current ?? window;\n    element.addEventListener(\"scroll\", updatePosition);\n\n    updatePosition();\n    return () => element.removeEventListener(\"scroll\", updatePosition);\n  }, [threshold, ref]);\n\n  return isScrolled;\n}\n","react/use-throwing-transform-track-value.example.tsx",{"id":267,"data":269},{"code":270},"import { z } from \"zod\";\nimport { useThrowingTransformTrackValue } from \"./use-throwing-transform-track-value\";\nimport { useState } from \"react\";\n\nexport default function Component() {\n\tconst [searchQuery, setSearchQuery] = useState\u003Cstring>();\n\n\tconst validSearchOptions = useThrowingTransformTrackValue(\n\t\tsearchQuery,\n\t\tz.string().min(1).max(8).parse,\n\t);\n\n\treturn (\n\t\t\u003Cdiv>\n\t\t\t\u003Cinput onChange={(e) => setSearchQuery(e.currentTarget.value)} />\n\t\t\t\u003Cp>raw output: {searchQuery}\u003C/p>\n\t\t\t\u003Cp>throwing transform track value output: {validSearchOptions}\u003C/p>\n\t\t\u003C/div>\n\t);\n}\n","react/use-throwing-transform-track-value.ts",{"id":271,"data":273},{"code":274},"import { useRef } from \"react\";\n\nexport function useThrowingTransformTrackValue\u003C\n\tT,\n\tTransformedValue,\n\tDefaultValue = undefined,\n>(\n\tvalueToTrack: T,\n\ttransformFn: (value: T) => TransformedValue,\n\tdefaultValue: DefaultValue = undefined as DefaultValue,\n) {\n\tconst transformedValue = useRef\u003CDefaultValue | TransformedValue>(\n\t\tdefaultValue,\n\t);\n\n\ttry {\n\t\ttransformedValue.current = transformFn(valueToTrack);\n\t} catch {}\n\n\treturn transformedValue.current;\n}\n","react/use-track-value.example.tsx",{"id":275,"data":277},{"code":278},"import { useEffect, useMemo, useState } from \"react\";\nimport { useTrackValue } from \"./use-track-value\";\n\nexport default function Component() {\n\tconst [page, setPage] = useState\u003Cnumber>(0);\n\tconst query = useQuery(fetch, page);\n\n\treturn (\n\t\t\u003Cdiv>\n\t\t\t\u003Cbutton onClick={() => setPage((page) => page - 1)}>back page\u003C/button>\n\t\t\t\u003Cbutton onClick={() => setPage((page) => page + 1)}>forward page\u003C/button>\n\t\t\t\u003Cp>this raw output: {query.data}\u003C/p>\n\t\t\t\u003Cp>\n\t\t\t\ttrack value output with Boolean: {useTrackValue(query.data, Boolean)}\n\t\t\t\u003C/p>\n\t\t\u003C/div>\n\t);\n}\n\nfunction fetch(page: number) {\n\treturn new Promise\u003Cstring>((resolve) =>\n\t\tsetTimeout(() => {\n\t\t\tresolve(`Successfully fetched page ${page}`);\n\t\t}, 2000),\n\t);\n}\n\n// naïve impl - do not use this in production code\nfunction useQuery\u003CT, Params>(\n\tquery: (params: Params) => Promise\u003CT>,\n\tparams: Params,\n) {\n\tconst [apiCallStore, setApiCallStore] = useState\u003CRecord\u003Cstring, T>>({});\n\tconst stringifiedParams = useMemo(() => JSON.stringify(params), [params]);\n\n\tuseEffect(() => {\n\t\tif (stringifiedParams in apiCallStore) return;\n\t\tquery(params).then((result) =>\n\t\t\tsetApiCallStore((store) => ({ ...store, [stringifiedParams]: result })),\n\t\t);\n\t}, [stringifiedParams]);\n\n\tif (stringifiedParams in apiCallStore) {\n\t\treturn { isLoading: false, data: apiCallStore[stringifiedParams] };\n\t}\n\n\treturn { isLoading: true, data: null };\n}\n","react/use-track-value.ts",{"id":279,"data":281},{"code":282},"import { useRef } from \"react\";\n\nexport function useTrackValue\u003CT>(\n\tvalueToTrack: T,\n\tconditionFn: (value: T) => unknown,\n) {\n\tconst transformedValue = useRef\u003CT>(valueToTrack);\n\n\tif (conditionFn(valueToTrack)) {\n\t\ttransformedValue.current = valueToTrack;\n\t}\n\n\treturn transformedValue.current;\n}\n","zustand/draft-store.example.tsx",{"id":283,"data":285},{"code":286},"import { create, type UseBoundStore, type StoreApi } from \"zustand\";\nimport {\n\tcreateContext,\n\tuseContext,\n\tuseRef,\n\ttype PropsWithChildren,\n} from \"react\";\nimport { useStore } from \"zustand\";\n\nexport function createDraftStore\u003CT extends object>(parentStore: StoreApi\u003CT>) {\n\tconst state = parentStore.getState();\n\tconsole.log(\"Initial state:\", state); // Let's see what we're starting with\n\n\tconst store = create\u003CT & { reset: () => void; push: () => void }>(\n\t\t(set, get) => {\n\t\t\tconst initialState = {\n\t\t\t\t...state,\n\t\t\t\treset: () => set(parentStore.getState()),\n\t\t\t\tpush: () => parentStore.setState(get()),\n\t\t\t};\n\t\t\tconsole.log(\"Created store with:\", initialState); // Verify store creation\n\t\t\treturn initialState;\n\t\t},\n\t);\n\n\t// Let's verify the store has what we expect\n\tconsole.log(\"Final store state:\", store.getState());\n\treturn store;\n}\n\nexport type CreateDraftStore\u003CT> = T extends StoreApi\u003Cinfer A>\n\t? UseBoundStore\u003CStoreApi\u003CDraftStore\u003CA>>>\n\t: T extends { useRoot: () => StoreApi\u003Cinfer A> }\n\t? UseBoundStore\u003CStoreApi\u003CDraftStore\u003CA>>>\n\t: never;\n\nexport function useCreateDraftStore\u003CT extends object>(\n\t// TODO: replace useRoot with a Symbol and look into how react determines use or change it to use__internal_root and hide the type\n\tanyParentStore: StoreApi\u003CT> | { useRoot: () => StoreApi\u003CT> },\n) {\n\tconst storeRef = useRef\u003CUseBoundStore\u003CStoreApi\u003CDraftStore\u003CT>>>>();\n\tconst parentStore =\n\t\t\"useRoot\" in anyParentStore ? anyParentStore.useRoot() : anyParentStore;\n\n\tif (!storeRef.current) {\n\t\tstoreRef.current = createDraftStore(parentStore);\n\t}\n\n\treturn storeRef.current;\n}\n\ntype Write\u003CT, U> = Omit\u003CT, keyof U> & U;\ntype DraftStore\u003CT> = Write\u003CT, { reset: () => void; push: () => void }>;\n\ntype UseStoreContext\u003CTStore> = (\u003CT = TStore>(\n\tselector?: (state: TStore) => T,\n) => T) & { useRoot: () => StoreApi\u003CTStore> };\n\nexport function createDraftStoreContext\u003CTStore extends object>(\n\tparentStore: UseStoreContext\u003CTStore>,\n) {\n\tconst StoreContext = createContext\u003CStoreApi\u003CDraftStore\u003CTStore>> | null>(null);\n\n\tconst Provider = (props: PropsWithChildren) => {\n\t\tconst storeRef = useRef\u003CStoreApi\u003CDraftStore\u003CTStore>>>();\n\t\tconst parentRootStore = parentStore.useRoot();\n\n\t\tif (!storeRef.current) {\n\t\t\tstoreRef.current = createDraftStore(parentRootStore);\n\t\t}\n\n\t\treturn \u003CStoreContext.Provider value={storeRef.current} {...props} />;\n\t};\n\n\tconst useRoot = () => {\n\t\tconst store = useContext(StoreContext);\n\t\tif (!store) {\n\t\t\tthrow new Error(\"Store hook must be used within its Provider\");\n\t\t}\n\t\treturn store;\n\t};\n\n\tconst useStoreContext = \u003CT = DraftStore\u003CTStore>>(\n\t\tselector: (state: DraftStore\u003CTStore>) => T = (state) =>\n\t\t\tstate as unknown as T,\n\t): T => useStore(useRoot(), selector);\n\n\treturn [Provider, Object.assign(useStoreContext, { useRoot })] as const;\n}\n","zustand/draft-store.tsx",{"id":287,"data":289},{"code":290},"import { create, type UseBoundStore, type StoreApi } from \"zustand\";\nimport {\n\tcreateContext,\n\tuseContext,\n\tuseRef,\n\ttype PropsWithChildren,\n} from \"react\";\nimport { useStore } from \"zustand\";\n\nexport function createDraftStore\u003CT extends object>(parentStore: StoreApi\u003CT>) {\n\tconst state = parentStore.getState();\n\tconsole.log(\"Initial state:\", state); // Let's see what we're starting with\n\n\tconst store = create\u003CT & { reset: () => void; push: () => void }>(\n\t\t(set, get) => {\n\t\t\tconst initialState = {\n\t\t\t\t...state,\n\t\t\t\treset: () => set(parentStore.getState()),\n\t\t\t\tpush: () => parentStore.setState(get()),\n\t\t\t};\n\t\t\tconsole.log(\"Created store with:\", initialState); // Verify store creation\n\t\t\treturn initialState;\n\t\t},\n\t);\n\n\t// Let's verify the store has what we expect\n\tconsole.log(\"Final store state:\", store.getState());\n\treturn store;\n}\n\nexport type CreateDraftStore\u003CT> = T extends StoreApi\u003Cinfer A>\n\t? UseBoundStore\u003CStoreApi\u003CDraftStore\u003CA>>>\n\t: T extends { useRoot: () => StoreApi\u003Cinfer A> }\n\t? UseBoundStore\u003CStoreApi\u003CDraftStore\u003CA>>>\n\t: never;\n\nexport function useCreateDraftStore\u003CT extends object>(\n\t// TODO: replace useRoot with a Symbol and look into how react determines use or change it to use__internal_root and hide the type\n\tanyParentStore: StoreApi\u003CT> | { useRoot: () => StoreApi\u003CT> },\n) {\n\tconst storeRef = useRef\u003CUseBoundStore\u003CStoreApi\u003CDraftStore\u003CT>>>>(undefined);\n\tconst parentStore =\n\t\t\"useRoot\" in anyParentStore ? anyParentStore.useRoot() : anyParentStore;\n\n\tif (!storeRef.current) {\n\t\tstoreRef.current = createDraftStore(parentStore);\n\t}\n\n\treturn storeRef.current;\n}\n\ntype Write\u003CT, U> = Omit\u003CT, keyof U> & U;\ntype DraftStore\u003CT> = Write\u003CT, { reset: () => void; push: () => void }>;\n\ntype UseStoreContext\u003CTStore> = (\u003CT = TStore>(\n\tselector?: (state: TStore) => T,\n) => T) & { useRoot: () => StoreApi\u003CTStore> };\n\nexport function createDraftStoreContext\u003CTStore extends object>(\n\tparentStore: UseStoreContext\u003CTStore>,\n) {\n\tconst StoreContext = createContext\u003CStoreApi\u003CDraftStore\u003CTStore>> | null>(null);\n\n\tconst Provider = (props: PropsWithChildren) => {\n\t\tconst storeRef = useRef\u003CStoreApi\u003CDraftStore\u003CTStore>>>(undefined);\n\t\tconst parentRootStore = parentStore.useRoot();\n\n\t\tif (!storeRef.current) {\n\t\t\tstoreRef.current = createDraftStore(parentRootStore);\n\t\t}\n\n\t\treturn \u003CStoreContext.Provider value={storeRef.current} {...props} />;\n\t};\n\n\tconst useRoot = () => {\n\t\tconst store = useContext(StoreContext);\n\t\tif (!store) {\n\t\t\tthrow new Error(\"Store hook must be used within its Provider\");\n\t\t}\n\t\treturn store;\n\t};\n\n\tconst useStoreContext = \u003CT = DraftStore\u003CTStore>>(\n\t\tselector: (state: DraftStore\u003CTStore>) => T = (state) =>\n\t\t\tstate as unknown as T,\n\t): T => useStore(useRoot(), selector);\n\n\treturn [Provider, Object.assign(useStoreContext, { useRoot })] as const;\n}\n","zustand/provider.example.tsx",{"id":291,"data":293},{"code":294},"import { create } from \"zustand\";\nimport { combine } from \"zustand/middleware\";\nimport { createStoreContext } from \"./provider\";\n\nconst [BearStoreProvider, useBearStore] = createStoreContext(\n  ({ defaultBears: bears = 0 }: { defaultBears?: number }) =>\n    create(\n      combine({ bears }, (set, get) => ({\n        addABear: () => set({ bears: get().bears + 1 }),\n      })),\n    ),\n);\n\nfunction Component() {\n  return (\n    \u003CBearStoreProvider defaultBears={5}>\n      \u003CChildComponent />\n    \u003C/BearStoreProvider>\n  );\n}\n\nfunction ChildComponent() {\n  const bears = useBearStore((state) => state.bears);\n  const addABear = useBearStore((state) => state.addABear);\n\n  return (\n    \u003Cdiv>\n      \u003Cspan>{bears}\u003C/span>\n      \u003Cbutton type=\"button\" onClick={addABear}>\n        Add\n      \u003C/button>\n    \u003C/div>\n  );\n}\n","zustand/provider.tsx",{"id":295,"data":297},{"code":298},"\"use client\";\n\nimport {\n  createContext,\n  useContext,\n  useRef,\n  type PropsWithChildren,\n} from \"react\";\nimport { useStore, type StoreApi } from \"zustand\";\n\ntype ProviderProps\u003CTParams> = PropsWithChildren\u003CTParams>;\n\nexport function createStoreContext\u003C\n  TStore extends object,\n  TParams = { store: StoreApi\u003CTStore> },\n>(\n  createStore: (params: TParams) => StoreApi\u003CTStore> = (({\n    store,\n  }: { store: StoreApi\u003CTStore> }) => store) as unknown as (\n    params: TParams,\n  ) => StoreApi\u003CTStore>,\n) {\n  const StoreContext = createContext\u003CStoreApi\u003CTStore> | null>(null);\n\n  const Provider = ({ children, ...params }: ProviderProps\u003CTParams>) => {\n    const storeRef = useRef\u003CStoreApi\u003CTStore>>(createStore(params as TParams));\n\n    return (\n      \u003CStoreContext.Provider value={storeRef.current}>\n        {children}\n      \u003C/StoreContext.Provider>\n    );\n  };\n\n  const useRoot = () => {\n    const store = useContext(StoreContext);\n    if (!store) {\n      throw new Error(\"Store hook must be used within its Provider\");\n    }\n    return store;\n  };\n\n  const useStoreContext = \u003CT = TStore>(\n    selector: (state: TStore) => T = (state) => state as unknown as T,\n  ): T => useStore(useRoot(), selector);\n\n  return [Provider, Object.assign(useStoreContext, { useRoot })] as const;\n}\n","zustand/superjson.example.ts",{"id":299,"data":301},{"code":302},"import { create } from \"zustand\";\nimport { combine, persist } from \"zustand/middleware\";\nimport { createSuperJSONStorage } from \"./superjson\";\n\nexport const useBearStore = create(\n  persist(\n    combine({ bears: 0 }, (set, get) => ({\n      addABear: () => set({ bears: get().bears + 1 }),\n    })),\n    {\n      name: \"food-storage\", // name of the item in the storage (must be unique)\n      storage: createSuperJSONStorage(() => sessionStorage), // (optional) by default, 'localStorage' is used\n    },\n  ),\n);\n","zustand/superjson.ts",{"id":303,"data":305},{"code":306},"import superjson from \"superjson\";\nimport type { PersistStorage } from \"zustand/middleware\";\n\nexport const createSuperJSONStorage = \u003CT>(\n  getStorage: () => Storage = () => localStorage,\n): PersistStorage\u003CT> => ({\n  getItem: (name) => {\n    const str = getStorage().getItem(name);\n    if (!str) return null;\n    return superjson.parse(str);\n  },\n  setItem: (name, value) =>\n    getStorage().setItem(name, superjson.stringify(value)),\n  removeItem: getStorage().removeItem,\n});\n","zustand/url.example.ts",{"id":307,"data":309},{"code":310},"import { create } from \"zustand\";\nimport { combine, persist } from \"zustand/middleware\";\nimport { createURLStorage } from \"./url\";\nimport { z } from \"zod\";\n\nconst BearsSchema = z.object({\n  bears: z.number(),\n});\n\nexport const useBearStore = create(\n  persist(\n    combine({ bears: 0 } satisfies z.infer\u003Ctypeof BearsSchema>, (set, get) => ({\n      addABear: () => set({ bears: get().bears + 1 }),\n    })),\n    {\n      name: \"food-storage\", // name of the item in the storage (must be unique)\n      storage: createURLStorage(BearsSchema), // zod schema\n    },\n  ),\n);\n","zustand/url.ts",{"id":311,"data":313},{"code":314},"import type { z } from \"zod\";\nimport type { PersistStorage } from \"zustand/middleware\";\nimport {\n  createStateDeserializer,\n  createStateSerializer,\n  type SerializeOptions,\n} from \"../state-serialization\";\n\nexport const createURLStorage = \u003CT>(\n  schema: z.ZodType\u003CT>,\n  options?: Omit\u003CSerializeOptions\u003CT>, \"paramName\">,\n): PersistStorage\u003CT> => {\n  const { createString } = createStateSerializer(schema);\n  const { fromString } = createStateDeserializer(schema);\n\n  return {\n    getItem(name) {\n      if (typeof window === \"undefined\") return null;\n\n      const params = new URLSearchParams(window.location.search);\n      const param = params.get(name);\n\n      if (!param) return null;\n\n      const result = fromString(param);\n      if (!result.success) return null;\n\n      return { state: result.data };\n    },\n\n    setItem(name, value) {\n      if (typeof window === \"undefined\") return;\n\n      const url = new URL(window.location.href);\n      const stringified = createString(value.state, options);\n      url.searchParams.set(name, stringified);\n      window.history.replaceState(null, \"\", url);\n    },\n\n    removeItem(name) {\n      if (typeof window === \"undefined\") return;\n\n      const url = new URL(window.location.href);\n      url.searchParams.delete(name);\n      window.history.replaceState(null, \"\", url.toString());\n    },\n  };\n};\n"]